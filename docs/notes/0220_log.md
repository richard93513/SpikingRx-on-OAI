# SpikingRx-on-OAI Debug Notes（本聊天室完整紀錄）
> 時間：2026-02-20（本聊天室）  
> 主題：用 **UE d_unmatched** 直接餵 OAI LDPCdecoder，證明 dump/bundle OK；最終定位到 **ldpctest_spx 的 decoder output 取法錯誤**（output buffer 根本沒被寫），導致 BER ≈ 0.5 的假象

---

## 0. 問題背景（為什麼要做這整套）
原本 pipeline：

1) OAI UE/gNB dump（fullgrid / demapper LLR / UE decoder-input LLR / UE d_unmatched / LDPC json / gNB tx bits）  
2) bundler 將同一組 frame/slot/idx/rnti/harq/rv 組合成 bundle  
3) ldpctest_spx（外部 wrapper）餵入 LLR，跑 OAI LDPC decoder，輸出 decoded bits  
4) 用 decoded bits vs txbits.bin 算 BER  

長期症狀：
- LDPC decoder 常常 `n_iter=25`（打滿）
- BER ≈ 0.49~0.50（像 random）
- 很像是「餵錯 buffer / RM mismatch / reorder mismatch」

策略：
- 直接切到最硬 Gate：**UE rate-unmatch 後的 d_unmatched（Ncb 長度）**  
  因為這是「LDPC 核心 decoder 真正吃進去的序列」，外部只要餵這個，就能排除所有外部 RM / deinterleave 的不一致。
- 若 direct-d_unmatched 能正常解碼（迭代數下降、結果合理），就能證明：  
  ✅ dump/bundle配對沒問題  
  ✅ UE 端 LLR/LDPC 本身沒問題  
  ❌ 問題在外部 wrapper（RM 或 decoder output handling）

---

## 1. UE / Raw Dump：確認 dump 的檔案都存在且大小正確

### 1.1 確認 UE LDPC json 有關鍵欄位
使用：
```bash
J=$(ls -t ~/SpikingRx-on-OAI/spx_records/raw/*_ldpc_idx*_dlsch*.json | head -n 1)
echo "LATEST_UE_LDPC=$J"
grep -nE '"llrLen"|"E_list"|"R_list"' "$J"
```

輸出例（已確認存在）：
- llrLen: 7200  
- E_list: [7200, 7200]  
- R_list: [13, 13]  

=> ✅ UE 端確實有把 decoder 相關參數 dump 完整（E/R）。

### 1.2 確認 UE decoder-input LLR（ue_decinllr）與 UE d_unmatched（ue_dunmatch）都有在更新
```bash
ls -lt ~/SpikingRx-on-OAI/spx_records/raw | grep ue_decinllr | head
ls -lt ~/SpikingRx-on-OAI/spx_records/raw | grep ue_dunmatch | head
```

檔案大小驗證：

- ue_decinllr：int16，長度 G=14400 → bytes = 14400*2 = 28800（實際檔案 28800）
- ue_dunmatch：每 segment int16，長度 Ncb=14784 → bytes = 14784*2 = 29568（實際檔案 29568）

=> ✅ dump 檔案存在、大小一致、符合預期。

### 1.3 發現：ue_dunmatch 檔名前面多了空白
現象：`cat f0933...seg00...bin` 會報找不到  
原因：檔名實際有前導空白（`ls -lt` 顯示前面有 spaces）

處置：
- 手動用變數 `SEG0=" f0933..."` 才 `cat` 得到
- 推定 dump 的 `snprintf(path, ...)` 前面被多印了空白（需修 dump 程式，避免檔名含空白）

=> ✅ 這是檔名格式 bug，但檔案內容本身存在且可用。

---

## 2. bundler：確認 bundle pairing 100% 正確

### 2.1 bundler 執行
```bash
python src/tools/bundle_records.py
```

結果：
- total UE keys = 1462
- built = 1462
- skipped_missing_ue_triple = 0
- skipped_missing_gnb_pair = 0
- skipped_bad_ue_ldpc_json = 0

=> ✅ 表示 bundler “join key” 配對 UE/gNB 沒漏、沒錯，且 UE json schema 也都正常。

### 2.2 以 frame 0777 為例找到 bundle
```bash
ls -1d ~/SpikingRx-on-OAI/spx_records/bundle/f0777_* | head
```

找到：
- f0777_s01_idx077701_...
- f0777_s11_idx077711_...

### 2.3 檢查 bundle 內容
在 `f0777_s11_idx077711_rnti04660_harq09_rv0/` 內確認：

- decoder_llr_int16.bin 28800 bytes（UE decoder-input LLR）
- txbits.bin 1185 bytes（A=9480 → A/8=1185）
- ldpc_cfg.txt 具備 BG/Zc/A/C/K/F/G/Qm/tbslbrm/mcs/rv_index/nb_layers/R
- meta_bundle.json 同時記錄 UE 與 gNB 的來源檔名（可溯源）

=> ✅ bundle 中所有檔案都對、且 meta 能追溯來源。

---

## 3. 產生 direct-d_unmatched 檔案（Ncb*C int16）

目標：把 ue_dunmatch seg00 + seg01 串起來，做成 bundle 內的 `d_unmatched_int16.bin`，讓 ldpctest_spx 能直接吃。

以 frame 0777 slot 11 idx077711 為例：

- SEG0=/home/.../raw/f0777_s11_ue_dunmatch_idx077711_..._seg00_Ncb14784.bin
- SEG1=/home/.../raw/f0777_s11_ue_dunmatch_idx077711_..._seg01_Ncb14784.bin

```bash
cat "$SEG0" "$SEG1" > d_unmatched_int16.bin
ls -lh d_unmatched_int16.bin
```

結果：
- 檔案大小 58K（精確應為 Ncb*C*2 = 14784*2*2 = 59136 bytes）

ldpctest_spx 之後也印出：expect int16(Ncb*C)=59136，且成功辨識 unmatched

=> ✅ direct-d_unmatched 檔案正確產生。

---

## 4. ldpctest_spx：成功支援 direct-d_unmatched（跳過 RM）

### 4.1 最初失敗原因
執行：
```bash
ldpctest_spx d_unmatched_int16.bin ldpc_cfg.txt decoded_bits_direct.bin
```

會報：
- unsupported file size=59136 bytes. Expect 14400 (int8) or 28800 (int16)

=> 原本 wrapper 只接受 G 或 2G，拒絕 unmatched 的 Ncb*C。

### 4.2 修正：讓 ldpctest_spx 接受 int16(Ncb*C)
做法：

- loader 依檔案 bytes 自動判斷：int8(G) / int16(G) / int16(Ncb*C)
- 若 len == Ncb*C：
  - input_is_unmatched=1
  - per-seg 直接切 Ncb 做 rm_seg
  - 跳過 deinterleave + rate-unmatch
- 同時 R 固定採用 ldpc_cfg.txt 中的 R=13（skip DERIVE）

### 4.3 direct-d_unmatched 跑起來後的關鍵 log（重大突破）
執行後顯示：

- [LLR] loaded int16(Ncb*C) d_unmatched ... (UNMATCHED)
- Segment 0 n_iter=1
- Segment 1 n_iter=1
- avg iterations/segment = 1.00

=> 這個結論非常硬：  
✅ UE dump 的 d_unmatched 序列與 LDPC decoder 完全一致（否則不可能 n_iter=1）  
=> RM / LLR 序列在 UE 端是正確的，而外部 direct feed 也成功。

---

## 5. 但 BER 仍 ≈ 0.5：定位「不是 dump/bundle，也不是 LLR/RM」

### 5.1 先排除 BER script 錯誤（bytes vs bits）
早期曾遇到：
- txbits.bin 是 bytes（A/8）
- decoded_bits.bin 是 1bit→1byte（A）
造成 broadcast mismatch

已改成：
- np.unpackbits(txbits.bin)[:A] vs decoded_bits[:A]

此後 BER 能算，但 direct-d 仍 ~0.486（顯然不是算式錯）。

### 5.2 排除 bitorder / reverse / invert / rev8 等所有常見轉換
做 brute force：
- unpackbits big/little
- reverse entire stream
- reverse bits per byte
- invert

結果全部一樣：best 仍 ~0.4858

### 5.3 排除 “decoded_bits 只是 bit packing 不同”
嘗試把 decoded bits pack 回 bytes 與 txbytes 比較：
- packbits(big/little)、xor 0xFF

結果 byte_equal 只有 4/1185 ≈ 0.003（近似隨機）

=> 結論：不是 bit packing 小問題，而是 decoded_bits 本身就不對。

---

## 6. 再更硬的證據：decoded_bits_direct.bin 竟然全 0

檢查：
```bash
python - <<'PY'
import numpy as np
x=np.fromfile("decoded_bits_direct.bin", dtype=np.uint8)
print(np.unique(x, return_counts=True), x.mean())
PY
```

輸出：
- 全部都是 0（9480 個 0）

=> 這解釋了 BER 近似 random：拿全 0 去比真實 txbits，會接近 0.5。  
也推翻了先前「可能只是 bitorder」的猜測：因為根本沒有 1。

---

## 7. 關鍵定位：LDPCdecoder 的 output buffer est_packed[] 根本沒被寫（全 0）

在 decoder loop 中加入 debug：
- 印 est_packed[j] 前 32 bytes
- dump est_packed_seg0.bin

跑 direct-d 後得到：

- [DBG] est_packed[0] first 32 bytes: 00 00 ... 00
- [DBG] est_packed[1] first 32 bytes: 00 00 ... 00
- xxd est_packed_seg0.bin 前 64 bytes 全 0

=> 這是「決定性證據」：  
✅ LDPCdecoder 的迭代（n_iter=1）是真的  
❌ 但它沒有把 hard decision bits 寫進你傳入的 output buffer  

所以問題不在 dump/bundle/LLR，而在 ldpctest_spx 如何呼叫 OAI LDPC decoder backend（outMode / output buffer semantics）。

---

## 8. 嘗試修 outMode：失敗原因

推測：
- backend 不支援 nrLDPC_outMode_BIT 或不會寫 output
- 改成 BYTE 模式可能會寫 0/1 per byte

但是編譯失敗：
- error: ‘nrLDPC_outMode_BYTE’ undeclared

=> 表示你目前 include 的 enum/定義裡沒有 BYTE mode（或名稱不同），因此下一步要先查 OAI 的 nrLDPC_outMode_t 到底有哪些值與對應語意。

---

## 9. 本聊天室最終已「確定」哪些事（給教授的硬結論）

### 9.1 已確定 dump / bundle 沒問題（為什麼能很確定）
- UE raw dump 檔案（ue_decinllr / ue_dunmatch）存在且檔案大小精準符合 G、Ncb（28800 / 29568）
- bundler built == total UE keys，且 skipped 全為 0，meta_bundle.json 可追溯 UE/gNB 來源
- 最硬證據：用 UE d_unmatched (Ncb*C) 直餵 LDPCdecoder，n_iter=1  
  這代表 UE 的 d_unmatched 序列與 decoder 完全一致  
  若 dump 配錯、或內容不對，迭代不可能只跑 1 次就收斂

=> dump/bundle/LLR序列與 decoder input 都沒問題。

### 9.2 已確定問題在 ldpctest_spx（而且是很特定的問題）
- LDPCdecoder() 的 output buffer est_packed[] 全 0（已印出、已 dump 檔）
- 因此後續任何 unpack/reconstruct 都只能得到全 0 TB bits
- 造成 BER ≈ 0.5 的根因：wrapper 沒有拿到 decoder 的 hard output

=> 不是 “沒用到 5G NR 解碼程式”，而是 “用了 decoder 但 output mode / output buffer 型態不對，backend 不寫”。

---

## 10. 下一個聊天室要做什麼（最重要的行動清單）

目標：讓 ldpctest_spx 能「正確取得 hard bits」，使 direct-d_unmatched 的 decoded bits 與 gNB txbits 對得上（BER→0）。

### Step A：查清楚 outMode enum 有哪些值（這一步最關鍵）
在 OAI tree 裡搜尋 outMode 定義：
```bash
cd ~/openairinterface5g
grep -R --line-number "nrLDPC_outMode" -n openair1 | head -n 50
grep -R --line-number "typedef.*outMode" -n openair1 | head -n 50
```

找到 nrLDPC_outMode_t 的 enum（或 #define），把所有可用 mode 列出來。你要回答的問題：
- 目前有哪些 outMode？（例如 BIT / LLR / something）
- 每個 outMode 的 output buffer 期望格式是什麼？（bit-packed？1 byte per bit？LLR？）

### Step B：用 “backend 真的會寫 output 的模式” 拿 hard decision
常見策略（依 enum 實際情況選）：

- B1) 若有 outMode = LLR 類型：  
  先讓 decoder 輸出 LLR（或 internal buffer），再在 wrapper 裡做 hard decision（>0 判 0/1）  
  這樣不依賴 BIT/packed 的實作一致性

- B2) 若只有 BIT mode，但 backend 需要不同 output buffer size/type：  
  有些 backend 在 BIT mode 會要求 output buffer 長度是 K_cb bytes（每 byte 一 bit），不是 bit-packed bytes  
  你要依 backend 定義調整：
  - est_packed 的型態與大小
  - outMode 的對應

### Step C：加一個最硬驗證：dump decoder output 的「非 0 率」
持續保留 debug：
- 印 est_packed 前 32 bytes
- xxd est_packed_seg0.bin 前 64 bytes  
要看到不是全 0，才算 output 取得成功。

### Step D：一旦 est_packed 不再全 0，立刻做 byte_equal / BER
依之前建立的比較工具：
- decoded_bits_direct.bin unique/mean
- packbits → byte_equal（應該接近 1.0）
- BER（應該接近 0）

---

## 11. 本聊天室重要檔案與狀態（方便接續）

使用的測試 bundle：
- `~/SpikingRx-on-OAI/spx_records/bundle/f0777_s11_idx077711_rnti04660_harq09_rv0/`

關鍵輸入檔：
- `d_unmatched_int16.bin`（Ncb*C int16, 59136 bytes）
- `ldpc_cfg.txt`（包含 R 13, rv_index 0, nb_layers 1）
- `txbits.bin`（gNB TB payload bytes, 1185 bytes, tbcrc 00000000）

關鍵 debug 檔：
- `est_packed_seg0.bin`（目前全 0，代表 output 沒寫）

關鍵現象：
- n_iter=1 但 output buffer 全 0 → ldpctest_spx output mode/buffer semantics mismatch

---

## 12. 下一個聊天室的第一句建議（直接貼）

我已經確認 UE dump/bundle 100% OK：UE d_unmatched (Ncb*C int16) 直餵 OAI LDPCdecoder，兩個 seg 都 n_iter=1。  
但 ldpctest_spx 的 output buffer est_packed[] 完全沒被寫（全 0），導致 decoded_bits 全 0、BER≈0.5。  
請幫我查 nrLDPC_outMode 真正支援哪些模式、各模式 output buffer 的格式/大小，並修改 ldpctest_spx 取得正確 hard bits（或改用輸出 LLR 再自做 hard decision）。
