# SpikingRx-on-OAI Debug Log（訓練完成後 → OAI 解碼整合階段）

本文件整理自「已成功完成 SpikingRx 訓練，並開始將 SpikingRx inference 接到 OAI LDPC 解碼器」之後，到目前為止的**完整 debug 流程紀錄**，依照實際聊天室出現順序、log 與程式脈絡整理而成，並附上接下來的建議行動步驟。

---

## 一、已完成的 Debug 全流程整理

### 1. 端到端管線成功串接（系統整合里程碑）

你已完成以下完整流程：

- 讀取 bundle 結構  
  SpikingRx-on-OAI/spx_records/bundle/fXXXX_sYY/
  - full-grid
  - meta
  - ldpc cfg

- SpikingRx inference 輸出：
  - infer_llr_float.npy（debug 使用）
  - infer_llr_int8.bin（提供 OAI LDPC decoder 使用）

- 呼叫外部解碼器：
  .../openairinterface5g/.../build/ldpctest_spx <llr.bin> <ldpc_cfg.txt> <decoded_bits.bin>

- Python 端：
  - 讀回 decoded bits
  - 與 txbits 比對
  - 計算 BER

結論：  
你已能端到端完成「SpikingRx → LLR → OAI LDPC decode → BER 計算」，這是系統整合層級的重要里程碑。

---

### 2. 第一個核心矛盾：LLR 長度 vs A 長度

你曾遇到的問題：

- OAI 期望的 LLR 長度：G = 14400  
- 解碼後得到的資訊位元長度：A = 9480

後續你釐清的事實：

- G = 14400  
  → rate-matching 後，每個 TB 的 soft bits 數
- A = 9480  
  → TB payload bits（不含 TB-CRC）
- decoder 內部還會處理：
  - segmentation（C = 2）
  - CB-CRC
  - TB-CRC
  - filler bits（F = 152）

成果：  
你建立了正確的長度關係框架，釐清 G / A / C / K / F 各自角色。

---

### 3. 打造可被 Python 呼叫的 standalone LDPC decoder（ldpctest_spx）

為了完全可控與可重現，你做了以下工作：

- 將 OAI LDPC decoder 獨立為可執行檔 ldpctest_spx
- 實作 ldpc_cfg.txt parser，支援：
  - frame / slot
  - BG / Zc
  - A / C / K / F / G
  - Qm / rv / tbslbrm / mcs …

- 將 inference LLR 讀入後：
  - 切分為每個 codeblock
  - 嘗試推導：
    - K'（由 A / C / F 回推）
    - code rate R（當時以近似方式選擇 R=23 對應 2/3）

- decoder 輸出：
  - packed bits → bit-by-byte 拆解
  - 重建 TB bits
  - 與 txbits 計算 BER

意義：  
你已將「OAI 內部解碼器」轉化為一個可外部控制、可 debug 的工具。

---

### 4. 第一波 linker error：rate matching / deinterleaving symbol 缺失

錯誤訊息：

undefined reference to nr_deinterleaving_ldpc  
undefined reference to nr_rate_matching_ldpc_rx

你完成的修正：

- 調整 CMakeLists.txt
- 在 target_link_libraries(ldpctest_spx ...) 中加入：
  - UTIL
  - SIMU
  - PHY_COMMON
  - PHY_NR_COMMON
- 使用 --start-group / --end-group 包住靜態庫，解決 link order 問題
- 成功重新編譯 ldpctest_spx

---

### 5. 第二波 linker error：LDPCdecoder / LDPCencoder 缺失（來自 ldpc_segment）

後續錯誤：

undefined reference to LDPCdecoder  
undefined reference to LDPCencoder

來源確認為：

- nrLDPC_coding_segment_decoder.c
- nrLDPC_coding_segment_encoder.c

問題本質：

- ldpc_segment 依賴 libldpc.so
- ldpctest_spx link chain 尚未完整帶入對應 LDPC library 或 link 順序不正確

你已成功將問題精準定位在：  
ldpc_segment → LDPC shared lib

---

### 6. 對齊 OAI 真正的 LDPC 解碼流程（關鍵里程碑）

你對照並貼出 nrLDPC_coding_segment_decoder.c 的核心流程，確認 OAI 原生解碼順序如下：

1. nr_deinterleaving_ldpc(E, Qm, ...)
2. nr_rate_matching_ldpc_rx(..., F, Foffset = K - F - 2Z)
3. 組 z[]：
   - 前 2Z 補 0
   - filler bits 補 127
   - 搬移 d 的兩段（跳過 filler）
4. packs_epi16 → int8 LLR
5. 呼叫 LDPCdecoder(...)
6. iteration 收斂後 copy bits + success flag

成果：  
你已讓「自行拼裝流程」與「OAI 原生定義」完全對齊。

---

### 7. 成功完成編譯（link chain 全數打通）

最終編譯結果：

Built target ldpc        (libldpc.so)  
Built target ldpctest_spx

表示：

- 所有 LDPC 相關 target
- rate-matching / deinterleaving
- LDPC shared library

皆成功連結。

---

### 8. 可完整 inference + decode，但 BER ≈ 0.5

實際測試範例：

- bundle：f0232_s11
- cfg：
  - BG=1
  - Zc=224
  - A=9480
  - C=2
  - F=152
  - G=14400
  - Qm=2

推導結果：

- K' = 4852
- 每段 E = 7200
- R = 23
- decoder 跑滿 25 iterations
- TB 重建成功（B = A + 24 = 9504）

結果：  
BER ≈ 0.502110

判斷：  
問題已不在「流程、長度、工程實作」，而是在 LLR 的語意層面。

---

## 二、建議的下一步（依優先順序）

### Step 1：兩個最便宜的 sanity check（不改 C、不重編）

1) LLR sign flip  
- OAI 定義：
  - LLR > 0 → bit = 0
  - LLR < 0 → bit = 1
- SpikingRx 可能相反

測試：  
llr *= -1

2) LLR scale up  
- LLR 量級過小 → LDPC 無法收斂

測試：  
llr *= 4 或 llr *= 8  
（再 clip 到 [-127, 127]）

這兩個測試可快速分類問題是：
- sign
- scale
- 或兩者皆非

---

### Step 2：用 OAI 原生 demapper 的 golden LLR 對齊順序

最常見 BER=0.5 原因是 bit order / interleaving 不一致。

建議作法：

- 在 OAI 原生 demapper dump 同一個 frame/slot 的 LLR
- 比較：
  - SpikingRx LLR
  - OAI golden LLR
- 分析：
  - sign correlation
  - bit-plane（Qm=2）是否交錯
  - rate-matching / circular buffer 起點是否錯

---

### Step 3：暫停 TB 重建，先專注 CB decode

在 LLR 尚未對齊前：

- TB 重建不是 OAI 主路徑
- 會增加 debug 複雜度

建議：
- 先只驗證每個 codeblock decode 是否合理
- 等 LLR 對齊後再回到 TB 與 BER

---

## 三、目前狀態一句話總結

你已經完成：

- build / link
- 38.212 segmentation 參數鏈
- OAI deinterleave + rate unmatch + LDPC decode 正確流程

現在唯一剩下的是：  
SpikingRx 輸出的 LLR，是否在「符號、尺度、順序」三件事上，與 OAI 期望完全一致。

---

## 四、最省時間的下一步

請回傳同一個 bundle 的兩個結果即可：

1. llr *= -1 的 BER  
2. llr *= 4（或 8）的 BER

我可以立即判斷下一步要鎖定的是：
- sign
- scale
- 還是 order（需進 golden LLR 對齊）
