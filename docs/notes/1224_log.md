### Appendix X. Debug Log: SpikingRx LLR → OAI LDPC Decoder Integration

---

### X.1 問題背景與除錯目標

本研究嘗試將 Spiking Neural Network Receiver（SpikingRx）所輸出的 soft information（LLR）回接至 OpenAirInterface (OAI) 5G NR LDPC decoder，以評估 AI-based receiver 與既有 5G PHY 解碼模組之相容性。

初期實驗發現，儘管 SpikingRx 能正常輸出 LLR，且解碼流程可順利執行，但解碼結果無法呈現合理的 BER/SNR 行為，因此啟動系統性除錯流程，以釐清錯誤來源。

本除錯流程之核心問題為：

錯誤是否來自 SpikingRx LLR 本身，或來自 LLR 回接 OAI LDPC decoder 的接收鏈路不完整？

---

### X.2 SpikingRx LLR 正確性驗證（關鍵結論）

#### X.2.1 LLR 數值與分佈檢查

首先針對 SpikingRx 輸出的 LLR 與 OAI 原生 demapper LLR 進行數值層面的比較，包括：

- 平均值（mean）
- 標準差（standard deviation）
- 最大／最小值（dynamic range）
- |LLR| 強度分佈

結果顯示，兩者在統計特性上高度一致，顯示 SpikingRx 所輸出的 soft information 並未出現數值爆炸、飽和或尺度錯誤等問題。

```
(.venv) richard93513@richard93513-Lenovo-ideapad-700-15ISK:~/SpikingRx-on-OAI$ python3 src/tests/compare_llr_oai_vs_spx.py \
  --bundle_dir /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0232_s11 \
  --G 14400 \
  --Qm 2
====================================================
[BUNDLE] /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0232_s11
[FILES] oai=oai_llr.bin, spx=infer_llr_float.npy
[PARAM] G=14400, Qm=2
====================================================

[STATS] OAI_LLR:
  mean      = -4.712500e-01
  std       = 1.149996e+01
  min/max   = -1.200000e+01 / 1.100000e+01
  mean|x|   = 1.149875e+01
  p(|x|<0.5)= 0.000000
  p(|x|<1.0)= 0.000000

[STATS] SPX_LLR:
  mean      = -4.607546e-01
  std       = 1.131583e+01
  min/max   = -1.895895e+01 / 1.764607e+01
  mean|x|   = 1.112970e+01
  p(|x|<0.5)= 0.000000
  p(|x|<1.0)= 0.000000

```

---

#### X.2.2 LLR 對應關係（Correlation Analysis）

進一步計算逐元素相關係數（Pearson correlation coefficient）以驗證 LLR 語意一致性。

比較對象：
- SpikingRx LLR  
- OAI demapper LLR  

結果：
- correlation ≈ 0.98  

此結果表示 SpikingRx 對每一個 bit 所給出的信心方向與強度，與 OAI demapper 幾乎一致，屬於高度語意對齊。

```
[CORR] corr(spx, oai)   = 0.983657
[CORR] corr(-spx, oai)  = -0.983657

[ERR ] MSE(spx, oai)    = 4.287486e+00
[ERR ] MAE(spx, oai)    = 1.656437e+00

[SWAP] corr(spx_swap, oai)  = 0.010959
[SWAP] corr(-spx_swap, oai) = -0.010959

Done.
```
---

#### X.2.3 關鍵反證實驗（Critical Counterexample）

為進一步排除 SpikingRx 造成錯誤的可能性，本研究直接將：

- OAI 原生 demapper 輸出的 LLR  
- 繞過 SpikingRx，直接送入自製 ldpctest_spx 解碼流程  

結果顯示，即使使用 OAI 自身產生的 LLR，解碼結果仍無法正確還原傳送資料。

此結果構成關鍵反證，證明解碼失敗並非由 SpikingRx LLR 所導致。

```
(.venv) richard93513@richard93513-Lenovo-ideapad-700-15ISK:~/SpikingRx-on-OAI$ python3 src/tests/oai_llr_to_int8.py \
  --bundle_dir /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11 \
  --clip 32.0 \
  --G 14400
[OK] wrote /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin (clip=32.0)
(.venv) richard93513@richard93513-Lenovo-ideapad-700-15ISK:~/SpikingRx-on-OAI$ /home/richard93513/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/ldpc_cfg.txt \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin
=== ldpctest_spx: SpikingRx → OAI LDPC decoder wrapper ===
[CFG] frame=221 slot=11 dlsch_id=0
[CFG] BG=1 Zc=224 A=9480 C=2 K=4928 F=152 G=14400 Qm=2 nb_layers=1
[CFG] rv_index=0 tbslbrm=184424 mcs=9
[LLR] file bytes = 14400 (expect G=14400)
[DERIVE] B=9504 B'=9552 F=152 → Kprime=4852 (每個 codeblock 的 bits, 含 CB-CRC)
[MAIN] splitted: C=2, each CB has E=7200 LLRs
[MAIN] BG=1 Zc=224 → N=14784, tbslbrm=184424 → Ncb=14784
[DERIVE] assume each CB has E=7200 LLRs (G/C)
[DERIVE] effective code rate ~ (Kprime-24)/E = 0.670556
[DERIVE] choose code rate approx 2/3 (diff=0.003889)
[DERIVE] mapped to R_ind=4 → code_rate_vec[R_ind]=23
CMDLINE: "/home/richard93513/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/ldpc_cfg.txt" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin" 
[MAIN] decParams[0]: BG=1 Z=224 R(code_rate)=23 Kprime=4852 numMaxIter=25
[MAIN] decParams[1]: BG=1 Z=224 R(code_rate)=23 Kprime=4852 numMaxIter=25
[DEC] Segment 0 / 2: calling LDPCdecoder()...
[DEC] Segment 0: LDPCdecoder() returned n_iter = 25
[DEC] Segment 1 / 2: calling LDPCdecoder()...
[DEC] Segment 1: LDPCdecoder() returned n_iter = 25
[DEC] average iterations per segment ~ 25.00
[OUT] collected 9704 codeblock bits (C=2, Kprime=4852)
[TB] B=9504 B'=9552, Kplus=4776 Kminus=4776 Cminus=0
[TB] reconstructed TB (含 TB-CRC) bits = 9504
[OUT] wrote TB payload A=9480 bits (1 bit → 1 byte) to '/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin'
```

---

### X.3 問題定位：LDPC Decoder 輸入鏈路不完整

#### X.3.1 原始錯誤假設

初期實作中，假設 LDPC decoder 的輸入可直接使用 demapper 輸出的 LLR。然而，經比對 3GPP NR 規範與 OAI 原始碼後確認，此假設並不成立。

---

#### X.3.2 正確的 NR 接收端流程（OAI 實作）

在 OAI NR PHY 中，LDPC decoder 的實際輸入需經過以下步驟：

Demapper LLR (E)  
→ LDPC deinterleaving  
→ LDPC rate-unmatching  
→ LDPC decoder input (Ncb)

若缺少上述任一處理步驟，即使 LLR 數值正確，仍會因 bit-to-check-node 對應錯亂而導致解碼失敗。

---

### X.4 ldpctest_spx 修正內容說明（僅補齊必要流程）

#### X.4.1 修正原則

- 不修改 OAI 原生 LDPC decoder  
- 不修改 SpikingRx 模型或權重  
- 僅補齊 OAI RX chain 中 decoder 前的必要處理模組  

---

#### X.4.2 新增之 RX 處理模組

在 ldpctest_spx.c 中，於呼叫 LDPCdecoder() 前，新增以下 OAI 原生函式：

- nr_deinterleaving_ldpc()  
- nr_rate_matching_ldpc_rx()  

上述函式與 OAI nr_dlsch_decoding() 中使用之版本一致。

---

#### X.4.3 重要參數設定與檢查

經比對 NR 規範與 OAI 原始碼，確認以下參數推導與設定：

- Code block size: K′ = (B′ + F) / C  
- Rate matching input length: E = G / C  
- Filler offset: Foffset = K − F − 2Z  
- HARQ buffer clear condition: clear = (segment == 0)  
- Redundancy version: rv_index = 0  

```
(.venv) richard93513@richard93513-Lenovo-ideapad-700-15ISK:~/openairinterface5g/cmake_targets/ran_build/build$ /home/richard93513/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/ldpc_cfg.txt \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin
=== ldpctest_spx: SpikingRx → OAI LDPC decoder wrapper ===
[CFG] frame=221 slot=11 dlsch_id=0
[CFG] BG=1 Zc=224 A=9480 C=2 K=4928 F=152 G=14400 Qm=2 nb_layers=1
[CFG] rv_index=0 tbslbrm=184424 mcs=9
[LLR] file bytes = 14400 (expect G=14400)
[DERIVE] B=9504 B'=9552 F=152 -> Kprime=4852 (每個 codeblock 的 bits, 含 CB-CRC)
[MAIN] splitted: C=2, each CB has E=7200 LLRs
[MAIN] BG=1 Zc=224 -> N=14784, tbslbrm=184424 -> Ncb=14784
[DERIVE] assume each CB has E=7200 LLRs (G/C)
[DERIVE] effective code rate ~ (Kprime-24)/E = 0.670556
[DERIVE] choose code rate approx 2/3 (diff=0.003889)
[DERIVE] mapped to R_ind=4 -> code_rate_vec[R_ind]=23
CMDLINE: "/home/richard93513/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/ldpc_cfg.txt" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin" 
[MAIN] decParams[0]: BG=1 Z=224 R(code_rate)=23 Kprime=4852 numMaxIter=25
[MAIN] decParams[1]: BG=1 Z=224 R(code_rate)=23 Kprime=4852 numMaxIter=25
[RM] seg=0: clear=1
[RM] seg=0: K=4928 F=152 Z=224 -> Foffset=4328 (expect K-F-2Z)
[RM] seg=1: clear=0
[RM] seg=1: K=4928 F=152 Z=224 -> Foffset=4328 (expect K-F-2Z)
[DEC] Segment 0 / 2: calling LDPCdecoder()...
[DEC] Segment 0: LDPCdecoder() returned n_iter = 25
[DEC] Segment 1 / 2: calling LDPCdecoder()...
[DEC] Segment 1: LDPCdecoder() returned n_iter = 25
[DEC] average iterations per segment ~ 25.00
[OUT] collected 9704 codeblock bits (C=2, Kprime=4852)
[TB] B=9504 B'=9552, Kplus=4776 Kminus=4776 Cminus=0
[TB] reconstructed TB (含 TB-CRC) bits = 9504
[OUT] wrote TB payload A=9480 bits (1 bit -> 1 byte) to '/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin'
```

---

#### X.4.4 非法 code rate 的處理

在除錯過程中發現，對於 BG = 1 的配置，部分 code rate（例如 R = 15、25）在此參數組合下屬於非法設定，會導致 LDPC decoder segmentation fault。

因此在測試階段僅保留實際合法之 code rate：

R ∈ {13, 23}

以確保解碼流程穩定執行。

```
(.venv) richard93513@richard93513-Lenovo-ideapad-700-15ISK:~/openairinterface5g/cmake_targets/ran_build/build$ /home/richard93513/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/ldpc_cfg.txt \
  /home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin
=== ldpctest_spx: SpikingRx → OAI LDPC decoder wrapper ===
[CFG] frame=221 slot=11 dlsch_id=0
[CFG] BG=1 Zc=224 A=9480 C=2 K=4928 F=152 G=14400 Qm=2 nb_layers=1
[CFG] rv_index=0 tbslbrm=184424 mcs=9
[LLR] file bytes = 14400 (expect G=14400)
[DERIVE] B=9504 B'=9552 F=152 → Kprime=4852 (每個 codeblock 的 bits, 含 CB-CRC)
[MAIN] splitted: C=2, each CB has E=7200 LLRs
[MAIN] BG=1 Zc=224 → N=14784, tbslbrm=184424 → Ncb=14784
[DERIVE] assume each CB has E=7200 LLRs (G/C)
[DERIVE] effective code rate ~ (Kprime-24)/E = 0.670556
[DERIVE] choose code rate approx 2/3 (diff=0.003889)
[DERIVE] mapped to R_ind=4 → code_rate_vec[R_ind]=23
CMDLINE: "/home/richard93513/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/oai_llr_int8.bin" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/ldpc_cfg.txt" "/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin" 
[MAIN] decParams[0]: BG=1 Z=224 R(code_rate)=23 Kprime=4852 numMaxIter=25
[MAIN] decParams[1]: BG=1 Z=224 R(code_rate)=23 Kprime=4852 numMaxIter=25
[RM] seg=0: K=4928 F=152 Z=224 => Foffset=4328 (expect K-F-2Z)
[RM] seg=1: K=4928 F=152 Z=224 => Foffset=4328 (expect K-F-2Z)

================= TRY R=13 =================
[TRY R=13] seg=0 n_iter=25
[TRY R=13] seg=1 n_iter=25
[TRY R=13] avg_iter=25.00 fail_cnt=0

================= TRY R=23 =================
[TRY R=23] seg=0 n_iter=25
[TRY R=23] seg=1 n_iter=25
[TRY R=23] avg_iter=25.00 fail_cnt=0
[OUT] collected 9704 codeblock bits (C=2, Kprime=4852)
[TB] B=9504 B'=9552, Kplus=4776 Kminus=4776 Cminus=0
[TB] reconstructed TB (含 TB-CRC) bits = 9504
[OUT] wrote TB payload A=9480 bits (1 bit → 1 byte) to '/home/richard93513/SpikingRx-on-OAI/spx_records/bundle/f0221_s11/decoded_bits_oai.bin'
```


---

### X.5 目前狀態總結（截至本階段）

已確認事項：

✔ SpikingRx 輸出的 LLR 在數值與語意上正確  
✔ LLR 回接失敗並非 SpikingRx 所致  
✔ NR RX chain 結構已補齊（deinterleaving + rate-unmatching）  
✔ LDPC decoder 可穩定執行，無 segmentation fault  
✔ TB 重組流程正確  

尚待驗證事項：

⚠ BER 是否隨 SNR 呈現合理趨勢  
⚠ SpikingRx 與 OAI baseline 在不同 SNR 下之效能差異  

---

### X.6 後續工作：SNR Sweep 與 BER 評估

下一階段將透過 RFsim 模式下調整通道 SNR，重新 dump 多組資料，進行 BER averaging 與 BER–SNR 曲線分析，以最終驗證整體 PHY 接收鏈路之效能正確性。

【此處貼上：  
SNR 設定方式、dump 指令與 BER 計算結果】

