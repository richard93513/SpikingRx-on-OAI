# SpikingRx-on-OAI：UE decoder-input LLR / R / rv_index 對齊後仍 iter=25、BER≈0.5 的 Debug 筆記（本聊天室全紀錄）

> 時間：2026-02-18  
> 目標：證明「bundle 已經配對正確」，並把 LLR dump 位置移到 **UE LDPC decoder 真正吃的序列**；再把外部 `ldpctest_spx` 的參數（R、rv_index、nb_layers）對齊；若仍不解，切到更硬 gate：UE 的 `d_unmatched`（rate-unmatch 後 buffer）直接餵 LDPCdecoder。

---

## 0. 背景與核心問題（為什麼要做這些）

原本 pipeline：

- OAI UE/gNB dump：fullgrid / demapper LLR / LDPC cfg / TX bits
- 用 SpikingRx 或 OAI demapper LLR → 外部 `ldpctest_spx` (OAI LDPC decoder wrapper) → decoded bits → BER

症狀：

- LDPC decoder 長期 `n_iter=25`（打滿）
- BER ~ 0.49~0.50（≈ random）
- LLR 分佈幾乎兩端飽和（-12/+11），且反號 BER 仍 ~0.5
- 代表不是簡單 sign convention，而是更像「序列/階段不一致」或「餵錯 buffer」

本聊天室的策略是做最乾淨的 Gate：

1. **先排除 bundle 配錯包**（UE/gNB/idx join 的一致性）
2. **把 UE dump 改成 decoder 真正吃的 buffer**
3. **讓外部 wrapper 使用 UE 真正的 R / rv_index / nb_layers**，不要猜
4. 若仍不行，**直接 dump UE 的 rate-unmatch 後 `d_unmatched`**，外部跳過 RM，只做 LDPCdecoder（最硬證據）

---

## 1. 重要結論（到本聊天室結束時的狀態）

### 1.1 已確認的事情

✅ UE 端已能 dump 出：

- `ue_decinllr`：UE decoder-input LLR（E_total=G，int16）
- `ue_ldpc json`：包含 `llrLen / E_list / R_list`
- `ue_dunmatch`：UE 端 rate-unmatch 後的 `d_unmatched`（每個 segment 一個檔，int16，長度 Ncb）

✅ bundler 已更新：

- bundle 內 `ldpc_cfg.txt` 已包含：
  - `R`
  - `rv_index`
  - `nb_layers`

✅ `ldpctest_spx` 已更新：

- 會讀 `ldpc_cfg.txt` 的 `R`，並「跳過猜碼率」  
  log 出現：`[MAIN] use cfg.R=13 ... (skip DERIVE)`  
  decParams 印出 `R=13`

✅ `ldpctest_spx` 也已吃到 `rv_index=1` 與 `nb_layers=1`（修正過去 rv=0 的致命 mismatch）

### 1.2 仍未解決的事情（本聊天室結束時仍然卡住）

❌ 即使 `R / rv_index / nb_layers` 對齊，且 **關掉 deinterleaving A/B 測試**，LDPC 仍 `n_iter=25`。

這代表「不是單純 R/rv mismatch，也不是 wrapper 多做一次 deinterleave」造成的。

---

## 2. UE side：做了哪些改動（Dump 點與格式）

### 2.1 在 UE `nr_dlsch_decoding.c` 找到真正餵 LDPC 的 LLR 指標

在 `nr_dlsch_decoding()` 裡，OAI 會設定：

- `segment_parameters->llr = dlsch_llr[DLSCH_id] + r_offset;`

這個 `dlsch_llr[...]` 是「送進 LDPC decoder interface 的 LLR」拼接（總長 G），因此是 **decoder-input LLR** gate。

### 2.2 新增 UE decoder-input LLR dump（ue_decinllr）

已新增 dump：

- 檔名：  
  `f%04d_s%02d_ue_decinllr_idx%06u_dlsch%02d_harq%02d_round%02d_rv%01d.bin`
- dtype：int16
- 長度：total_E = sum(E_list) = G（例：G=14400 ⇒ bytes=28800）

確認：`ls -lh raw | grep ue_decinllr` 可看到大量檔案，大小一致 28800 bytes。

### 2.3 新增 UE rate-unmatch 後 buffer dump（ue_dunmatch）

目的：取得 LDPC core 真正吃的 `d_unmatched`（Ncb 長度），外部直接餵 decoder。

新增 dump：

- `harq_process->d[r]` 每個 segment 一個檔
- 檔名：
  `f%04d_s%02d_ue_dunmatch_idx%06u_dlsch%02d_harq%02d_round%02d_rv%01d_seg%02d_Ncb%05d.bin`
- dtype：int16
- 長度：Ncb（BG1: N = 66*Z, Ncb=min(tbslbrm, N)；例：Z=224 → N=14784 → Ncb=14784）
- 檔案大小驗證：Ncb*2 bytes；例：14784*2=29568 bytes（實際 ls 顯示就是 29568）

確認指令（本聊天室已有輸出）：

```bash
ls -lt ~/SpikingRx-on-OAI/spx_records/raw | grep ue_dunmatch | head
