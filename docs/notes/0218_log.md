# SpikingRx-on-OAI：UE decoder-input LLR / R / rv_index 對齊後仍 iter=25、BER≈0.5 的 Debug 筆記（本聊天室全紀錄）

> 時間：2026-02-18  
> 目標：證明「bundle 已經配對正確」，並把 LLR dump 位置移到 **UE LDPC decoder 真正吃的序列**；再把外部 `ldpctest_spx` 的參數（R、rv_index、nb_layers）對齊；若仍不解，切到更硬 gate：UE 的 `d_unmatched`（rate-unmatch 後 buffer）直接餵 LDPCdecoder。

---

## 0. 背景與核心問題（為什麼要做這些）

原本 pipeline：

- OAI UE/gNB dump：fullgrid / demapper LLR / LDPC cfg / TX bits
- 用 SpikingRx 或 OAI demapper LLR → 外部 `ldpctest_spx` (OAI LDPC decoder wrapper) → decoded bits → BER

症狀：

- LDPC decoder 長期 `n_iter=25`（打滿）
- BER ~ 0.49~0.50（≈ random）
- LLR 分佈幾乎兩端飽和（-12/+11），且反號 BER 仍 ~0.5
- 代表不是簡單 sign convention，而是更像「序列/階段不一致」或「餵錯 buffer」

本聊天室的策略是做最乾淨的 Gate：

1. **先排除 bundle 配錯包**（UE/gNB/idx join 的一致性）
2. **把 UE dump 改成 decoder 真正吃的 buffer**
3. **讓外部 wrapper 使用 UE 真正的 R / rv_index / nb_layers**，不要猜
4. 若仍不行，**直接 dump UE 的 rate-unmatch 後 `d_unmatched`**，外部跳過 RM，只做 LDPCdecoder（最硬證據）

---

## 1. 重要結論（到本聊天室結束時的狀態）

### 1.1 已確認的事情

✅ UE 端已能 dump 出：

- `ue_decinllr`：UE decoder-input LLR（E_total=G，int16）
- `ue_ldpc json`：包含 `llrLen / E_list / R_list`
- `ue_dunmatch`：UE 端 rate-unmatch 後的 `d_unmatched`（每個 segment 一個檔，int16，長度 Ncb）

✅ bundler 已更新：

- bundle 內 `ldpc_cfg.txt` 已包含：`R / rv_index / nb_layers`

✅ `ldpctest_spx` 已更新：

- 會讀 `ldpc_cfg.txt` 的 `R`，並「跳過猜碼率」  
  log 出現：`[MAIN] use cfg.R=13 ... (skip DERIVE)`  
  decParams 印出 `R=13`

✅ `ldpctest_spx` 也已吃到 `rv_index=1` 與 `nb_layers=1`（修正過去 rv=0 的致命 mismatch）

### 1.2 仍未解決的事情（本聊天室結束時仍然卡住）

❌ 即使 `R / rv_index / nb_layers` 對齊，且 **關掉 deinterleaving A/B 測試**，LDPC 仍 `n_iter=25`。

=> 代表「不是單純 R/rv mismatch，也不是 wrapper 多做一次 deinterleave」造成的。

---

## 2. UE side：做了哪些改動（Dump 點與格式）

### 2.1 在 UE `nr_dlsch_decoding.c` 找到真正餵 LDPC 的 LLR 指標

在 `nr_dlsch_decoding()` 裡，OAI 會設定：

- `segment_parameters->llr = dlsch_llr[DLSCH_id] + r_offset;`

這個 `dlsch_llr[...]` 是「送進 LDPC decoder interface 的 LLR」拼接（總長 G），因此是 **decoder-input LLR** gate。

### 2.2 新增 UE decoder-input LLR dump（ue_decinllr）

已新增 dump：

- 檔名：  
  `f%04d_s%02d_ue_decinllr_idx%06u_dlsch%02d_harq%02d_round%02d_rv%01d.bin`
- dtype：int16
- 長度：total_E = sum(E_list) = G（例：G=14400 ⇒ bytes=28800）

確認：`ls -lh raw | grep ue_decinllr` 可看到大量檔案，大小一致 28800 bytes。

### 2.3 新增 UE rate-unmatch 後 buffer dump（ue_dunmatch）

目的：取得 LDPC core 真正吃的 `d_unmatched`（Ncb 長度），外部直接餵 decoder。

新增 dump：

- `harq_process->d[r]` 每個 segment 一個檔
- 檔名：
  `f%04d_s%02d_ue_dunmatch_idx%06u_dlsch%02d_harq%02d_round%02d_rv%01d_seg%02d_Ncb%05d.bin`
- dtype：int16
- 長度：Ncb（BG1: N = 66*Z, Ncb=min(tbslbrm, N)；例：Z=224 → N=14784 → Ncb=14784）
- 檔案大小驗證：Ncb*2 bytes；例：14784*2=29568 bytes

確認指令：

```bash
ls -lt ~/SpikingRx-on-OAI/spx_records/raw | grep ue_dunmatch | head
```

---

## 3. bundler：`bundle_records.py` 做了哪些改動

### 3.1 新增掃描 UE decoder-input LLR（RE_UE_DECINLLR）

加入 regex：

- `RE_UE_DECINLLR = r"^f...._ue_decinllr_idx......_dlsch.._harq.._round.._rv.\.bin$"`

以 tuple key `(frame, slot, idx, dlsch, harq, round, rv)` 索引。

### 3.2 bundle 內新增檔案

在 bundle output：

- `decoder_llr_int16.bin` ← copy UE `ue_decinllr`
- `demapper_llr_float.bin`（保留舊 demapper llr debug）
- `fullgrid.bin`
- `txbits.bin`
- `ldpc_cfg.txt`
- `meta_bundle.json`

### 3.3 `ldpc_cfg.txt` 內容擴增（關鍵）

本聊天室新增輸出：

- `rv_index`
- `nb_layers`
- `R`（取 UE json 的 `R_list[0]`）

例：

```txt
BG 1
Zc 224
A 9480
C 2
K 4928
F 152
G 14400
Qm 2
tbslbrm 184424
mcs 9
rv_index 1
nb_layers 1
R 13
```

---

## 4. `ldpctest_spx`：本聊天室做了哪些改動（以及結果）

### 4.1 讓 `ldpctest_spx` 讀 cfg 的 R（不再猜碼率）

修改點：

- `ldpc_cfg_t` 增加 `int R;`
- cfg parser 支援 `R`
- `main()` 若 `cfg.R>0`：直接用 `cfg.R` 作為 decoder 參數，不跑 `DERIVE/pick`

驗證 log：

- `[CFG] ... R=13`
- `[MAIN] use cfg.R=13 from ldpc_cfg.txt (skip DERIVE)`
- `decParams[..] R(code_rate)=13`

### 4.2 補齊 `rv_index / nb_layers`（避免 RM 用錯 rv）

修正後：

- bundle `ldpc_cfg.txt` 包含 `rv_index 1`、`nb_layers 1`
- wrapper log 顯示吃到 `rv_index=1`、`nb_layers=1`

### 4.3 A/B：關掉 deinterleaving（仍然 iter=25）

假設：UE dump 的 LLR 可能已經 deinterleaved，wrapper 再做一次會打亂。

實驗：把 `nr_deinterleaving_ldpc(...)` 改成 `memcpy(...)`（skip deinterleave）

結果：iter 仍然 25

=> 結論：問題不是「多做一次 deinterleave」。

---

## 5. BER 計算的坑（已釐清）

- `txbits.bin` 長度是 `A/8` bytes（例：1185）
- `decoded_bits.bin` 長度是 `A` bytes（例：9480），因為 wrapper 寫法是「1 bit -> 1 byte」

所以要比 BER，必須把 `txbits.bin` unpack 成 bit：

```python
import numpy as np

# read A
A=None
with open("ldpc_cfg.txt","r") as f:
    for line in f:
        p=line.strip().split()
        if len(p)==2 and p[0]=="A":
            A=int(p[1]); break
assert A is not None

tx_bytes = np.fromfile("txbits.bin", dtype=np.uint8)
tx_bits  = np.unpackbits(tx_bytes, bitorder="big")[:A].astype(np.uint8)

dec_bits = np.fromfile("decoded_bits.bin", dtype=np.uint8)[:A].astype(np.uint8)

ber = (tx_bits != dec_bits).mean()
err = int((tx_bits != dec_bits).sum())
print("A =", A, "BER =", ber, "errors =", err)
```

---

## 6. 下一個聊天室要做什麼（最重要：後續檢查清單）

目標：用「UE `d_unmatched`」直接餵 LDPCdecoder，完全跳過外部 rate-unmatch，一次判斷問題在「外部 RM」還是「LLR 本身」。

### 6.1 Step 1：挑一組最新 idx 的 UE `dunmatch` + 對應 UE LDPC json

```bash
J=$(ls -t ~/SpikingRx-on-OAI/spx_records/raw/*_ldpc_idx*_dlsch*.json | head -n 1)
echo "UE_LDPC=$J"
cat "$J" | sed -n '1,80p'
```

找同 idx 的 `seg00/seg01`：

```bash
IDX=$(basename "$J" | sed -n 's/.*_idx\([0-9]\{6\}\)_.*/\1/p')
ls -lt ~/SpikingRx-on-OAI/spx_records/raw | grep "ue_dunmatch_idx${IDX}" | head -n 10
```

你應該會看到兩個檔：

- `...seg00_Ncb14784.bin`
- `...seg01_Ncb14784.bin`

### 6.2 Step 2：把 seg00 + seg01 串成一個檔（Ncb*C）

```bash
cd ~/SpikingRx-on-OAI/spx_records/raw
cat fXXXX_sYY_ue_dunmatch_idxZZZZZZ_..._seg00_Ncb14784.bin \
    fXXXX_sYY_ue_dunmatch_idxZZZZZZ_..._seg01_Ncb14784.bin \
  > /tmp/d_unmatched_int16.bin

ls -lh /tmp/d_unmatched_int16.bin
# 大小應該是 (Ncb*2seg)*2 bytes = 14784*2*2 = 59136 bytes
```

### 6.3 Step 3：讓 `ldpctest_spx` 支援 “direct d_unmatched” 模式（必做）

目前 `ldpctest_spx` 仍是吃 `decoder_llr_int16.bin`（E_total=G），然後自己 RM 到 Ncb。

下一聊天室要改：

- 若輸入檔的 int16 長度 == `Ncb*C` ⇒ 視為 `d_unmatched`，跳過：
  - deinterleave
  - rate_unmatch
- 直接把 Ncb 長度資料（每 seg Ncb）量化成 int8 → 丟 `LDPCdecoder()`（core）

驗證成功的標誌：

- iter 不再永遠 25（通常會大幅下降）
- BER 會明顯 < 0.5（即使不一定完全 0）

若 direct-d 仍然 iter=25：不是外部 RM 的錯，而是 upstream LLR/通道/對齊更上游的問題。

### 6.4 Step 4：bundle 也應該收 `d_unmatched`（可選，但很推薦）

把 UE `ue_dunmatch seg00/seg01` 在 bundler 中合併成：

- `d_unmatched_int16.bin`（`Ncb*C` int16）
- meta 記錄 `Ncb` 與檔名

如此每個 bundle 都能「一鍵 direct-d」跑 LDPCdecoder。

---

## 7. 本聊天室最後的判斷（給教授/下一聊天室看的結論）

已排除：bundle 配錯包（idx join、欄位對齊已做）

已完成：UE 端 dump 到 decoder-input LLR（`ue_decinllr`）與更硬的 `d_unmatched`（`ue_dunmatch`）

已修正：外部 wrapper 使用 cfg 的 `R / rv_index / nb_layers`

仍失敗（iter=25）表示：

- 外部 RM 細節仍與 UE 內部不同（最可能）
- 或 `decoder_llr_int16` 仍不是完全正確 stage（次可能，因為已準備用 `d_unmatched` 做硬驗證）

下一步最關鍵驗證：direct feed UE `d_unmatched` → LDPCdecoder，跳過外部 RM。

---

## 8. 下一個聊天室起手式（直接貼這句就能接上進度）

> 我已經能 dump `ue_dunmatch`（每個 seg 一個 Ncb 長度的 int16），請幫我把 `ldpctest_spx` 改成支援 `direct-d_unmatched` 模式（若輸入 len == Ncb*C 就跳過 RM 直接 decoder），並告訴我哪幾行改什麼。

