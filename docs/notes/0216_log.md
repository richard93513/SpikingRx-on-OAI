# SpikingRx-on-OAI：LDPC BER≈0.5 / 全部 Bundle mismatch 問題 — 交接筆記（2026-02-16）

## 0) 這次聊天要解決什麼？
目標是把 OAI dump 出來的資料（fullgrid / oai_llr / ldpc_cfg / txbits）做成 bundle，跑：
fullgrid → SpikingRx inference → (量化成 int8 LLR) → 用 OAI LDPC decoder (ldpctest_spx) 解碼 → 跟 txbits 比對算 BER。

現在遇到的現象：
- 不管用 SpikingRx 的 LLR、或用 OAI 自己的 oai_llr.bin，丟進 ldpctest_spx 解碼後 BER 都接近 0.5
- decoder 兩個 codeblock segment 都迭代 25 次卡死（n_iter=25）
- batch 跑起來：每個 bundle 都被判定為 **BUNDLE_MISMATCH (txbits != cfg/llr)**

結論（目前已被證據支撐）：
> 不是量化、不是 clear flag、不是 SpikingRx 推論本身。
> 是「bundle 內的 txbits.bin 與 (ldpc_cfg.txt + oai_llr.bin) 不是同一個 TB」→ pairing 壞掉 → 任何解碼都會 BER≈0.5。


---

## 1) 我們做過哪些關鍵檢查？（按時間線）

### 1.1 確認 `ldpctest_spx` 真的吃到最新 source（避免 build 沒更新）
做法：
A) 確認 CMake 指向的 source 檔案存在：
- `/home/richard93513/openairinterface5g/openair1/PHY/CODING/TESTBENCH/ldpctest_spx.c`

B) source 內有 build tag（用 grep）：
- `grep -n "SPX BUILD TAG" .../ldpctest_spx.c`

C) binary 內也要找得到該 tag（strings）：
- `strings .../build/ldpctest_spx | grep "SPX BUILD TAG"`

第一次看到：
- source 有 tag，但 binary 沒 tag → 代表 build 沒吃到

後來在 build dir 內：
- `make -j$(nproc) ldpctest_spx VERBOSE=1`
- `strings .../ldpctest_spx | grep "SPX BUILD TAG"` 成功
=> 確認 binary 是新版本（含 tag：`Kprime_ts+clear_fix`）

✅ 這一步排除了「你改 C code 但其實沒編進去」的可能。


### 1.2 檢查量化後的 SpikingRx LLR int8 分佈（避免全 0/資訊量被吃掉）
你曾抓到某些 bundle 的 `infer_llr_int8.bin` 幾乎都落在 -1..1：
- nonzero ratio ~ 0.13
- abs>=5 ratio = 0
- abs>=10 ratio = 0

這意味 LDPC 看起來像「幾乎沒信心的 LLR」→ 很容易 BER≈0.5。

因此我們把推論腳本的量化策略改成：
- 若 bundle 有 `oai_llr.bin`：用 OAI LLR 對齊 sign + alpha（LS）後再量化 → 叫 `oai_scale_match`
- 若沒有 `oai_llr.bin`：才用 percentile scaling fallback

但後續即使你改成 fallback（讓 int8 幾乎滿分佈、nonzero 接近 1.0、甚至有飽和），仍 BER≈0.5，
代表「量化不是根因」。

✅ 這一步排除了「只是因為 int8 太小」這種單點原因。


### 1.3 檢查 `oai_llr.bin` 的 dtype 是否讀錯（避免 float32 被當 int32）
你用檔案大小判斷：
- `oai_llr.bin` bytes = 57600
- G = 14400
- 57600 / 14400 = 4 bytes → 可能是 int32 或 float32

你實際讀出：
- 用 int32 讀：值範圍到 1e9（不合理）
- 用 float32 讀：min -12 max 11 std ~11.5（合理）

=> 確認 OAI LLR 應該是 float32（或至少用 float32 才合理）

✅ 這一步排除「dtype 讀錯」導致相關係數/alpha 崩掉。


### 1.4 最致命的 sanity check：用 OAI 自己的 LLR 解碼，看 BER 是否仍 0.5
你跑：
- `check_oai_llr_decode.py --scale 16`
- `check_oai_llr_decode.py --scale 32`

兩者結果：
- `BER(oai_llr->ldpctest_spx) ≈ 0.50021`（幾乎正好 0.5）
- 且 decoder 仍 n_iter=25 卡死

這個結果非常關鍵：
> 如果 OAI 自己的 LLR 丟進同一個 ldpctest_spx 都 BER≈0.5，
> 那問題一定不是 SpikingRx、不在量化、不在 clear，
> 而是「你拿來對比的 txbits 不是同一個 TB」或「cfg/rv/harq 不一致」。

✅ 這一步直接把 root-cause 指向「bundle pairing / dump 對齊」。


---

## 2) 你目前的 dump 是怎麼做的？（資料來源與檔名）

你目前的 raw dump（spx_records/raw）大致包含：

### 2.1 UE side
- fullgrid：
  - `f####_s##_fullgrid_idx######.bin`
  - 內容：full OFDM grid（你偏好 full-grid 版本）
- demapper LLR（OAI 原生 LLR）：
  - `f####_s##_llr_idx######.bin`  （你 bundle 裡叫 `oai_llr.bin`）
- UE LDPC cfg json（含 dlsch/harq/round/rv）：
  - `f####_s##_ldpc_idx######_dlsch##_harq##_round##_rv#.json`

### 2.2 gNB side
- gNB LDPC cfg json（含 rnti/rv）：
  - `f####_s##_ldpc_idx######_rnti#####_rv#.json`
- gNB txbits（TB bits packed）：
  - `f####_s##_txbits_idx######_rnti#####_rv#.bin`

> 核心：UE 與 gNB 的 idx counter 來源可能不同步（不同 module、不同觸發時序），
> 所以光用 newest / frame-slot 可能會配錯 TB。


---

## 3) Bundle 現在是怎麼做的？（為什麼會 mismatch）

### 3.1 bundle 目標目錄結構
bundle/f####_s##/ 內固定放：
- `fullgrid.bin`
- `oai_llr.bin`
- `ldpc_cfg.txt`   （從 UE ldpc json 轉出 key-value）
- `txbits.bin`
- `meta_bundle.json`（記錄原始來源檔名與 match 資訊）

### 3.2 目前 bundler 的 pairing 邏輯（你提供的版本）
對每個 fullgrid：
1) fullgrid：用 `frame/slot + idx_fg` 確定
2) llr：必須同 frame/slot 且 idx 相同（這段通常最準）
3) UE ldpc json：
   - 先找同 frame/slot 且 idx 相同（理想）
   - 找不到就 fallback：同 frame/slot + rv（rv 從 gNB ldpc json 取）
4) gNB ldpc json：同 frame/slot 取 newest（用來拿 rnti/rv）
5) txbits：用 (frame/slot + rnti + rv) 找 newest；若沒 rnti 就同 frame/slot+rv 找 newest

### 3.3 mismatch 的原因（目前最可信）
你已經證明很多 bundle：
- 用 OAI LLR 解碼 BER≈0.5（即使 scale 16/32 都一樣）
=> 代表 bundle 內的 `txbits.bin` 幾乎肯定不是該 `oai_llr.bin/ldpc_cfg.txt` 對應的 TB。

也就是：
- fullgrid / oai_llr / ue_ldpc 可能互相一致（UE chain）
- 但 gNB txbits 很可能抓到別的 TB（例如不同 HARQ、不同 RNTI、不同 round、甚至不同 frame-slot 雖同名但不同事件）
- 你的 “pick newest” 會把 txbits 配到「時間上最近」而不是「語意上同一筆傳輸」。

所以 batch inference 全部被判定 mismatch 是合理的。


---

## 4) Inference / Decode pipeline 現在是怎麼跑的？

### 4.1 推論（SpikingRx）
輸入：
- `bundle/.../fullgrid.bin`

流程：
- `load_oai_fullgrid(fullgrid.bin, H_out=32, W_out=32, T=3)` → 產生 spiking tensor
- `SpikingRxModel(T=3, base_ch=16, out_bits=14400)` → 輸出 llr_float (G=14400)

輸出：
- `infer_llr_float.npy`（float32, len=14400）

### 4.2 量化（int8 LLR for OAI LDPC）
輸入：
- `infer_llr_float.npy`（SpikingRx float LLR）
- 若存在：`oai_llr.bin`（OAI demapper LLR）

策略：
- Mode A（推薦）：`oai_scale_match`
  - 用 `corr(spx, oai)` vs `corr(-spx, oai)` 決定 sign
  - 用 least-squares 算 alpha：alpha_ls=(spx·oai)/(spx·spx)
  - 用 p99 限制 alpha_cap 避免過度飽和
  - 最後 `round + clip` 到 int8
- Mode B：percentile scaling（fallback）

輸出：
- `infer_llr_int8.bin`
- `infer_meta.json`（記錄 mode/sign/alpha/sat_ratio/nonzero 等）

注意：你目前看到的例子（f0029_s11）：
- mode=oai_scale_match
- alpha 只有 ~0.026
- i8_abs_p99 = 1.0
- nonzero = 0.071
=> 代表對齊後仍非常小（但即使你把量化弄很大，也無法救 bundle mismatch）。


### 4.3 解碼（OAI LDPC wrapper：ldpctest_spx）
呼叫：
- `ldpctest_spx infer_llr_int8.bin ldpc_cfg.txt decoded_bits.bin`

它會：
- 讀 cfg：BG/Zc/A/C/K/F/G/Qm/rv/tbslbrm/mcs
- derive Kprime_ts(K') = K - F - 2Z （你 log 顯示 K'=4776）
- per codeblock 分割 E=G/C
- rate-matching RX（你已加 clear=1 以確保 buffer 清乾淨）
- LDPCdecoder() 跑 max 25 iterations
- 把 C 個 codeblock bits 拼回 TB（含 CRC）再輸出 payload A bits

輸出：
- `decoded_bits.bin`（每 bit 用 1 byte 0/1）

### 4.4 BER 計算（對 txbits）
- txbits.bin 是 packed bits → `np.unpackbits` 取 A bits
- decoded_bits.bin 已是 0/1 bytes → 取 A
- BER = mean(tx != dec)


---

## 5) 目前「每一包都 mismatch」的直接證據（你貼的 log）
以 f0029_s11 為例：

- spx 解碼後 BER=0.476899（接近 0.5）
- 更重要：用 `oai_llr_int8.bin` 解碼後 BER=0.502110（幾乎正好 0.5）
- decoder iter=25 卡死，顯示完全沒收斂

=> 只要 OAI LLR 本身都無法解出正確 txbits，就可以判定：
> bundle 內 txbits.bin != (cfg/llr) 的 TB
這不是模型/量化/clear 能修的問題。


---

## 6) 下一步要怎麼做（給下一個聊天室的工作指令）

### 6.1 你現在要解的不是 inference，而是「bundle pairing 必須改成語意一致」
建議優先順序（由最穩到最容易踩雷）：

(1) **用同一個“共同鍵”把 gNB txbits 跟 UE cfg/llr 對起來**
- 最理想是 dump 時就把同一個 key 寫進檔名：例如 (frame, slot, harq_pid, rv, rnti, ndi, tb_crc 等)
- 目前你只有：
  - UE cfg 檔名有 dlsch/harq/round/rv
  - gNB txbits 檔名有 rnti/rv
  - idx 在 UE/gNB 端不保證同一套計數器
=> bundler 才會靠 newest 去猜，必然配錯

(2) **短期 workaround：把 gNB side dump 增強，寫出 harq_pid / frame/slot / tb_crc**
- 只要能把同一筆 TB 的 “signature” 變得唯一，就能 deterministic pairing

(3) **用內容做 pairing（最後手段，但可用）**
- 例如用 OAI LLR 先解出 decoded_bits_oai，再和 txbits 比對：
  - 反過來找：哪個 txbits 能讓 BER(oai_llr) 最小（接近 0）
  - 但這是 O(N) 配對搜尋，raw 很大會慢

### 6.2 你必做的 sanity gate（以後每包都要先過這關）
對每個 bundle 必須先做：
- `BER_oai = decode(oai_llr.bin) vs txbits.bin`
若 `BER_oai > 0.45`：
- 直接標記 bundle mismatch，不要拿這包做 SpikingRx 評估

這個 gate 是你現在能最快縮小問題範圍的工具。


---

## 7) 本聊天最終狀態（你現在的系統已確認做到哪些事）
已完成且確認有效：
- ldpctest_spx binary 確實更新（strings 能看到 build tag）
- clear=1 已改（log 顯示 seg0/seg1 clear=1）
- oai_llr.bin dtype 正確判斷為 float32（int32 讀會爆炸）
- 量化策略可切換（oai_scale_match / percentile），並可輸出 meta

尚未解決、也是當前主因：
- bundle pairing（txbits 與 UE cfg/llr 不對齊）
- 因此所有 BER 都接近 0.5，無法反映真實 receiver 表現


---

## 8) 附：你目前在用的 batch inference 腳本概念（目的）
你已要求「完整 batch inference」：
- 對每個 bundle：
  - SpikingRx inference → infer_llr_int8.bin
  - ldpctest_spx decode spx llr
  - 同時 decode OAI llr（sanity）
  - 若 OAI 也 0.5 → 直接標 mismatch

這份 batch 的價值不是得到好 BER，而是：
- 快速把「可用 bundle」篩出來
- 或證明「目前 bundling 100% 壞掉」→ 必須回去修 dump/配對規則


---

# TL;DR（給教授/自己快速看）
- 我們先確認 ldpctest_spx 確實吃到最新 code（build tag）。
- 再確認量化/clear 都不是 root-cause，因為：
  - **OAI 自己的 LLR 解碼對 txbits 仍 BER≈0.5**
- 所以問題是：**bundle 裡 txbits.bin 與 (oai_llr.bin + ldpc_cfg) 不是同一個 TB**。
- 下一步必須修：dump 的命名/元資料，讓 gNB txbits 能 deterministic 對到 UE cfg/llr；或至少用 BER_oai gate 篩出可用 bundle。
