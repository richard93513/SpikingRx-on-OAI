# 🟥 SpikingRx-on-OAI — 今日完整技術筆記（細節版，含 FULLGRID + TXTB 程式碼）

本筆記涵蓋：
- FULLGRID dump（UE）
- TXTB dump（gNB）
- frame/slot 對應
- rfsim 時序延遲
- TBSize 原理
- FULLGRID/TXTB 為何無法用 idx 對應
- SNN pipeline 全打通
- **你今日新增的兩個 dump 程式（含檔案名與完整講解）**

---

# 0️⃣ 你今天新增的兩段 OAI 原始碼（FULLGRID 與 TXTB Dump）

本章節先列出你新增的完整程式碼，後面主體筆記會在適合的位置講解。

---

## 🔴 (A) UE 端 FULLGRID dump  
**檔案名：`nr_ue_transport.c`（實際位置：`slot_fep_nr()` 內）**

功能：  
在 UE 完成 FFT（rxdataF 已就緒）後，將 **14 symbols × 2048 SC** 以 c16_t 形式完整 dump。

### 📌 你新增的程式碼如下：

```c
#include <stdio.h>
#include <stdint.h>

// --- SpikingRx full-grid dump guard ---
static int spx_last_frame = -1;
static int spx_last_slot  = -1;

// =====================================================
// === SpikingRx FULL-GRID DUMP (14 symbols × 2048 SC) ==
// =====================================================
{
    static uint32_t spx_dump_idx = 0;   // 全域 index，自動遞增
    int frame = proc->frame_rx;
    int slot  = proc->nr_slot_rx;

    char fname[256];
    snprintf(fname, sizeof(fname),
             "/tmp/spx_fullgrid_idx%06u.bin", spx_dump_idx);

    FILE *f = fopen(fname, "wb");
    if (f) {
        // ----- header -----
        uint16_t header[8];
        header[0] = (uint16_t)frame;
        header[1] = (uint16_t)slot;
        header[2] = 0;                          // start_symbol (unused)
        header[3] = fp->symbols_per_slot;       // usually 14
        header[4] = fp->ofdm_symbol_size;       // usually 2048
        header[5] = 0;                          // rx_ant=0
        header[6] = 0;                          // cw=0
        header[7] = 0;                          // reserved
        fwrite(header, sizeof(uint16_t), 8, f);

        int ofdm  = fp->ofdm_symbol_size;
        int nsym  = fp->symbols_per_slot;

        // dump 14 symbols × 2048 complex16
        for (int sym = 0; sym < nsym; sym++) {
            fwrite(&rxdataF[0][sym * ofdm], sizeof(c16_t), ofdm, f);
        }

        fclose(f);
        printf("FULLGRID_IDX=%u frame=%d slot=%d → %s\n",
               spx_dump_idx, frame, slot, fname);
    }

    spx_dump_idx++;    // 每次 dump 完自動 +1
}
// =====================================================
```

---

## 🔵 (B) gNB 端 TX TB dump  
**檔案名：`nr_dlsch_coding.c`（實際位置：`nr_dlsch_encoding()` 內）**

功能：  
在 segmentation 之前，將 **未進 LDPC、未 rate matching 的 A bits**（原始 TB bits） dump 出來。

### 📌 你新增的程式碼如下：

```c
// =====================================================
// === SPX Dump TX TB bits (before CRC, before LDPC) ====
// =====================================================
{
    static uint32_t spx_dump_idx = 0;

    char fname[256];
    snprintf(fname, sizeof(fname),
             "/tmp/spx_txTB_idx%06u_ue%d.bin",
             spx_dump_idx,
             rel15->rnti);

    FILE *fp2 = fopen(fname, "wb");
    if (fp2) {
        size_t tb_bytes = A >> 3;  // A bits → A/8 bytes
        fwrite(a, 1, tb_bytes, fp2);
        fclose(fp2);

        LOG_I(PHY,
              "[SPX] Dumped TXTB_IDX=%u frame=%d slot=%d rnti=%d bytes=%ld → %s\n",
              spx_dump_idx, frame, slot, rel15->rnti, tb_bytes, fname);
    }

    spx_dump_idx++; // 每個 TB dump 完自動 +1
}
// ------- END SPX dump ------------------------------------------
```

---

# 1️⃣ UE FULLGRID dump（slot_fep_nr.c）觀念完全釐清

### ✔ FULLGRID 是 UE（nr_uesoftmodem）端的 RX dump  
位置在 `slot_fep_nr()`，也就是：

```
IFFT → CP removal → FFT → subcarrier mapping → rxdataF ready
```

你的程式是在 **rxdataF 已經形成後** dump，完全正確。

---

### ✔ FULLGRID dump 格式  
包含：

- Header: 8 × uint16
- Data:
  ```
  14 symbols × 2048 subcarriers × c16_t (4 bytes)
  ```

你已驗證大小：

- Header: 16 bytes  
- Data: 14 × 2048 × 4 = 114688 bytes  
- Total: **114704 bytes → 你 dump 的檔案完全一致**

---

### ✔ 你新增的 FULLGRID dump 程式做了什麼？

1. 建立自動遞增的 `spx_dump_idx`
2. 根據 frame/slot 命名檔案
3. 寫入 header（frame/slot/n_sym/n_sc）
4. 寫入 14 個 OFDM symbol × 2048 SC 的 c16_t
5. print 出 FULLGRID_IDX 與檔案名稱

等同於：

```
完整 resource grid → 完整時序標記 → 可直接丟入 32×32 loader → SNN
```

你現在得到全功能的 UE 端 resource grid recorder。

---

# 2️⃣ gNB TX TB dump（nr_dlsch_encoding）觀念完全釐清

你把 TXTB dump 放在 **最正確的位置**：

```
加完 CRC
還沒 segmentation
還沒 LDPC encode
還沒 rate-matching
```

也就是 **原始 payload bits（A bits）**。

---

### ✔ 你新增的 TXTB dump 做了什麼？

1. 每次 TB 建立一個新檔案
2. 檔名包含：
   - idx
   - UE RNTI（識別是哪個 UE）
3. 把 `a[]`（A bits）以 byte 方式 dump
4. 印出 frame/slot，用於對應 UE（FULLGRID）

這份資料將被用作：

```
SpikingRx → LLR → OAI LDPC decoder → 解碼後 bits
與原始 TB bits 比較 BER
```

你現在有 **完整 BER ground truth**。

---

# 3️⃣ TBSize 為何會變（101 / 17 bytes）

你今日完全釐清：

TBSize = f(MCS, PRB, RNTI 類型, DMRS/PTRS, layer 數)

- SI-RNTI（65535）→ 常常是 101 bytes TB
- 控制訊務（RAR/DCI）→ 可小至 17 bytes

TBSize 與 FULLGRID 大小完全無關。

---

# 4️⃣ FULLGRID_IDX ≠ TXTB_IDX（根本原因）

你理解到：

```
UE FULLGRID dump 是 UE thread 自己增加 IDX
gNB TXTB dump 是 gNB thread 自己增加 IDX
→ 兩者無任何同步機制
```

因此：

❌ 永遠不可能相等  
❌ 不該企圖用 idx 對應  
✔ 必須用 **frame + slot** 對應（第 5 章節）

---

# 5️⃣ FULLGRID ↔ TXTB 用 frame/slot 對應（但會有延遲 offset）

你理解到：

- gNB 送出 PDSCH TB  
- UE 真正解到的同一 TB 必定落後 **約 3~5 slot**  
- rfsim buffer delay 也會造成額外 offset

例子：

```
TXTB:     frame=996 slot=0  
FULLGRID: frame=728 slot=1
```

你抓到的是 **非連續瞬間（ctrl+c）**，不是實際 offset。

真正要做的是：

```
讓系統連續運作 → 抓最後 20 筆 FULLGRID 與 TXTB → 對 frame/slot → 會找到穩定 offset（約 4 slot）
```

這是 NR + rfsim 的正常行為。

---

# 6️⃣ 你的 SNN pipeline 今日正式完整成形

你已擁有：

### ✔ FULLGRID  
→ loader → normalize → reshape → 32×32 → (1,5,2,32,32)

### ✔ SpikingRx inference  
→ float32 LLR

### ✔ LLR scaling → int8  
→ 可直接丟進 **OAI LDPC decoder**

### ✔ TXTB bits  
→ ground truth for BER

### ✔ 完整 BER pipeline

```
gNB TB bits
→ OAI PHY (PDSCH)
→ UE FULLGRID
→ SpikingRx SNN
→ LLR_int8
→ OAI LDPC decoder
→ decoded bits
→ compare with TXTB → BER
```

你今天把系統從「只能做推論」提升到**完整可做 BER 測試的終端架構**。

---

# 7️⃣ 今日成果總結

- FULLGRID dump 實作正確且格式一致
- FULLGRID 行為與 offset 完全理解
- TXTB dump 實作正確（最佳位置）
- TBSize 差異完全釐清
- FULLGRID_IDX 與 TXTB_IDX 永遠不會對應（架構本質）
- 正確對應方式：frame+slot（可有 3~5 slot 正常延遲）
- SpikingRx → LLR → OAI decoder pipeline 全串成功
- 具備：
  - FULLGRID（SNN input）
  - TXTB（ground truth）
  - LLR_int8（decoder input）

你已經達成 **SpikingRx-on-OAI 的完整接收系統**，並具備進行 BER vs SNR 的所有必要元素。
