# SpikingRx-on-OAI / ldpctest_spx Debug 全紀錄筆記（本聊天室從頭到尾）

> 時間範圍：2026-02-21（本聊天室）  
> 目標：把「UE 端真正吃進 LDPC core 的資料」(d_unmatched) 拉出來，丟給外部 `ldpctest_spx`，確認外部 wrapper 是否能 **100% 複製 OAI UE LDPC decoding 結果**；並逐步排除「dump/對齊/格式/長度/記憶體/位元抽取」等問題。  
> 結果：  
> - ✅ `ldpctest_spx` 已可穩定跑完（修掉 segfault），能把 `d_unmatched_int16.bin` 丟進 `LDPCdecoder()` 得到輸出。  
> - ❌ 但 BER 仍約 0.5（≈ 隨機），表示「**不是通道太差**」，而是「**我們拿來比對的 bits 或我們從 decoder output 抽 bits 的方式不對**」，或「dump 的 d_unmatched 不是我們以為的那個意義」。  
> - 下一步重點：**dump UE 端真正的 decoded CB/TB bits（harq_process->c[r] / b[DLSCH_id]）**來當 ground-truth，並反推外部 wrapper 的 bit 抽取方式。

---

## 0. 背景：為什麼要走到 d_unmatched gate？

先前即使把：
- bundle 配對（frame/slot/idx/rnti/harq/rv）  
- UE decoder-input LLR (`ue_decinllr`)  
- `R`、`rv_index`、`nb_layers` 等  
都對齊後，外部 LDPC wrapper 還是出現 BER≈0.5。

因此本聊天室改用更硬的 gate：

> 直接 dump UE 端 LDPC core 真正吃的 buffer：`harq_process->d[r]`  
> 這個就是 rate-unmatch 的輸出（我稱為 `d_unmatched`），理論上餵到同一份 OAI LDPC decoder 應該必定能 decode 成跟 UE 一樣的結果。

---

## 1. 第一個編譯錯：`est_packed` / `est_bits` 未宣告

### 1.1 現象
編譯報：
- `error: 'est_packed' undeclared`
- 後來改名又變成：
- `error: 'est_bits' undeclared`

### 1.2 你做的檢查（很關鍵）
你用 grep/nl 把「你那個版本的 `ldpctest_spx.c`」現況查清楚：

```bash
F=~/openairinterface5g/openair1/PHY/CODING/TESTBENCH/ldpctest_spx.c

grep -nE "outMode[[:space:]]*=|nrLDPC_outMode_" "$F" | head -n 50
grep -nE "\best_packed\b|\best_bits\b|\bllr_out\b" "$F"
nl -ba "$F" | sed -n '560,610p'
```

結果看到：你真正存在的輸出 buffer 是：
```c
int8_t llr_out[MAX_SEGMENTS][MAX_BLOCK_LENGTH];
```

但你 debug fwrite 還在寫 `est_bits[0]`（根本不存在），所以才報未宣告。

### 1.3 修正（一次改對的核心）
把 line 587 那種 `fwrite(est_bits[0], ...)` 全部改成寫你真的存在的 `llr_out[0]`：

```c
fwrite(llr_out[0], 1, MAX_BLOCK_LENGTH, fd);
```

### 1.4 結果
✅ 編譯成功，log 顯示：
- `Linking C executable ldpctest_spx`
- `Built target ldpctest_spx`

---

## 2. 跑起來後發現：d_unmatched_int16.bin 全是 0（harq09）

### 2.1 現象
`ldpctest_spx` 跑出來 `llr_out` 全是 0，decoded 全是 0：
- `[DBG] llr_out[0] first 32: 0 0 0 ...`
- `decoded unique [(0, 9480)]`

你也用 python 檢查 `d_unmatched_int16.bin`：
- len(int16)=29568
- min/max=0
- nonzero=0

並且回頭在 raw 目錄找對應 `ue_dunmatch seg` 檔，也全部是 0。

### 2.2 結論（當下）
這不可能是正常 LLR/d_unmatched；代表那個 HARQ/round 的那次 dump 不是有效資料（可能當次是空/未更新/被清掉/沒有實際 decode）。

---

## 3. 換到 harq15：找到真的有值的 d_unmatched / decinllr

你要求我幫你檢查 `f0777_s11_idx077711_rnti04660_harq15_rv0`，你跑完得到：

### 3.1 ue_dunmatch（seg00/seg01）都有值
- nonzero ratio ≈ 0.487（合理）
- min/max = -12..12

### 3.2 ue_decinllr 也都有值
- nonzero ratio = 1.0
- min/max = -12..12

✅ 代表這一包 HARQ15 的 UE dump 才是有效資料，可以用來做外部 wrapper 的 replication test。

---

## 4. 把 seg00+seg01 concat 成 d_unmatched_int16.bin 後：第一次跑出 segfault

### 4.1 你做的步驟
```bash
cd ~/SpikingRx-on-OAI/spx_records/bundle/f0777_s11_idx077711_rnti04660_harq15_rv0

SEG0=~/SpikingRx-on-OAI/spx_records/raw/f0777_s11_ue_dunmatch_idx077711_dlsch00_harq15_round00_rv0_seg00_Ncb14784.bin
SEG1=~/SpikingRx-on-OAI/spx_records/raw/f0777_s11_ue_dunmatch_idx077711_dlsch00_harq15_round00_rv0_seg01_Ncb14784.bin

cat "$SEG0" "$SEG1" > d_unmatched_int16.bin
~/openairinterface5g/cmake_targets/ran_build/build/ldpctest_spx d_unmatched_int16.bin ldpc_cfg.txt decoded_bits_direct.bin
```

### 4.2 現象
程式「記憶體區段錯誤」。

### 4.3 你用 gdb 抓到的關鍵 backtrace
segfault 在：
- `nrLDPC_llr2bit(numLLR=15232, ...)`

這裡非常關鍵：numLLR=15232 代表 LDPC decoder 在你這條 outMode path 內部認為 output buffer 長度是 15232（BG1, Zc=224 → 68*Z=15232）。

而你當時給 decoder 的 output buffer 長度是 `MAX_BLOCK_LENGTH=8448`（只夠 K'=22*Z=4928 的最大值），所以一定會寫爆，必然 segfault。

---

## 5. 第二次大修：修掉 segfault（out_len, alignment, BITINT8）

### 5.1 你要求「一次改完、完整 code」
因此我們把 `ldpctest_spx.c` 重構成：

- 支援三種 LLR input：  
  - int8 (G)  
  - int16 (G)  
  - int16 (Ncb*C) 直接視為 d_unmatched

- 若 matched (G)：  
  - `nr_deinterleaving_ldpc`  
  - `nr_rate_matching_ldpc_rx` 產生 d_unmatched

- 若 unmatched (Ncb*C)：  
  - 跳過 RM，直接當作每個 segment 的 Ncb 輸入

### 5.2 針對 segfault 的「精準修正點」

(1) 改用 outMode = BITINT8  
```c
decParams[j].outMode = nrLDPC_outMode_BITINT8;
```

(2) output buffer 必須是 out_len = (BG1:68Z, BG2:52Z)  
```c
const int out_len = (cfg.BG == 1) ? (68 * cfg.Zc) : (52 * cfg.Zc);
```

(3) output buffer 必須 32-byte 對齊 + 長度補齊到 32 倍數（AVX2）  
```c
const int out_len_aligned = (out_len + 31) & ~31;
bit_out[j] = (int8_t*)memalign(32, out_len_aligned);
memset(bit_out[j], 0, out_len_aligned);
```

你也加了 debug 印出 alignment：
- `[DBG] bit_out[0]=... mod32=0 out_len=15232 aligned=15232`

### 5.3 結果
✅ segfault 消失，兩段都能 decode 完成：
- `[DEC] Segment 0: n_iter=2`
- `[DEC] Segment 1: n_iter=2`
- `[OUT] wrote TB payload ...`

---

## 6. 仍然 BER≈0.5：代表「不是 decoder 跑不起來」，而是「bits 對不上」

### 6.1 你做的 BER 檢查（很完整）
用 python 讀：
- txbits.bin（gNB side）
- decoded_bits_direct.bin（外部 wrapper輸出）

然後比較 BER ≈ 0.498。

你還做了更完整的 sanity：
- bitorder big / little 都試
- dec 反相 (1-dec) 也試
- tx 反相 (1-tx) 也試

結果仍約 0.5。

✅ 這個檢查結論很強：不是單純 bitorder 或 0/1 定義錯（已經排除）。

### 6.2 meta_bundle.json 確認 bundle 配對資訊
你列出 bundle 檔案與 meta_bundle.json：

- frame=777 slot=11 idx=77711
- UE: harq=15 rv=0
- gNB: pdu=0 rv=0 tbcrc=00000000
- ue_ldpc_extra:  
  - llrLen=7200  
  - E_list=[7200,7200]  
  - R_list=[13,13]

✅ 至少 bundle pairing 這一層「看起來」一致。

---

## 7. 本聊天室做到這裡，我們已經確定了什麼？

### 7.1 已確定（Hard facts）
- harq15 這包的 UE d_unmatched 是有效資料（非全 0）。
- 外部 ldpctest_spx 已能穩定呼叫 OAI LDPC decoder library，不再 segfault。
- LDPCdecoder() 回傳 iter=2（不是直接 fail），表示 decoder 真的做了計算。
- 但外部輸出的 TB bits 與 gNB 的 txbits 比對仍 BER≈0.5。

### 7.2 這代表什麼（推論）
這種 BER≈0.5 最常見不是「通道太爛」，而是：

(A) 你拿來當 ground-truth 的 txbits.bin 不是 UE 當下那個 TB 的 payload bits  
例如：txbits dump 位置不對（在 scramble 前後？含CRC與否？段落順序？或是別的 TB）  
或 gNB/UE 的 HARQ process（或 PDU index） mismatch

(B) 你從 decoder output 抽 bits 的方式不對  
目前我們是走 BITINT8 output mode，拿 bit_out 來抽 K_cb bits，再做 TB reconstruction。  
但注意：BITINT8 path 內部 `nrLDPC_llr2bit(numLLR=15232)` 的語意看起來更像「把整個 codeword 的 LLR 轉成 hard bits」，  
不一定等於 OAI UE 最後用來輸出的 `harq_process->c[r]`（decoded CB payload bytes）。

也就是：bit_out 很可能不是 “K'=4928 的 systematic info bits”，而是 “N+2Z 的 codeword hard decisions”。  
如果是這樣，你再怎麼抽 offset 都會錯到 BER≈0.5。

---

## 8. 下一步要做什麼（最重要的行動清單）

目標：把「OAI UE 自己認為 decode 成功的 payload bits」dump 出來，和 gNB txbits 做對照。  
只要這一步做完，就能一槍打穿：到底是 “txbits ground-truth 錯” 還是 “wrapper 抽 bits 錯”。

### 8.1 在 UE 端（nr_dlsch_decoding.c）dump harq_process->c[r]（每段 decoded CB payload）

UE 在 post-decode 會做：

```c
memcpy(b[DLSCH_id] + offset,
       harq_process->c[r],
       (harq_process->K >> 3) - (harq_process->F >> 3) - ((harq_process->C > 1) ? 3 : 0));
```

這裡的 `harq_process->c[r]` 就是 UE 最終認定的 decoded segment bytes（已去 filler/CRC 部分依 OAI 實作）。

要 dump 的東西（每個 segment r）：
- dump `harq_process->c[r]`（bytes）
- dump 長度 `Kr_bytes = (K>>3) - (F>>3) - (C>1?3:0)`（OAI 真正拿去組 TB 的 data bytes）

Dump 檔名建議（放 spx_records/raw，沿用你現有 naming）：
- `f%04d_s%02d_ue_c_idx%06u_dlsch%02d_harq%02d_round%02d_rv%d_seg%02d.bin`

做完後，你就能在 bundle 裡把 seg0/seg1 串起來得到 UE 的 TB bytes（不用猜規則，因為 OAI 自己已經做完）。

### 8.2 同時 dump UE 的 b[DLSCH_id]（整個 TB bytes，UE 最終輸出）

在 post-decode 最後，UE 有 `b[DLSCH_id]`（整個 TB bytes）。你也可以直接 dump：
- `b[DLSCH_id]` 前 `TBS/8` bytes

這是 UE 真正交給上層的 PDSCH payload（最有權威的 ground truth）。

檔名建議：
- `f%04d_s%02d_ue_tb_idx%06u_dlsch%02d_harq%02d_round%02d_rv%d.bin`

### 8.3 有了 UE ground truth 後，要做的比對（兩個方向）

(1) 比對 gNB txbits vs UE tb  
- 如果 gNB txbits 與 UE tb 本來就不相等 → bundle pairing 或 gNB dump 位置/定義錯。  
- 如果相等 → 代表 gNB txbits 是對的，問題在 wrapper。

(2) 比對 wrapper output vs UE tb  
- 若 wrapper output ≠ UE tb → wrapper 抽 bits 邏輯不對。  
- 若 wrapper output = UE tb 但 ≠ gNB txbits → gNB txbits 不是正確 ground truth。

### 8.4 如果 wrapper 抽 bits 邏輯不對，最可能錯在哪？
依目前所有現象，可能性排序：

1) BITINT8 output 的 bit_out 並不是 “decoded info bits(Kprime)”  
   它可能是 “N+2Z codeword hard bits”  
   UE 真正用的是 `harq_process->c[r]`（decoded CB payload bytes）  
   所以 wrapper 應該改成：直接讓 LDPC decoder 回傳 payload（或對應 OAI 用來填 c[r] 的 output mode），  
   而不是用 `nrLDPC_llr2bit` 那條 path 的輸出來自己重組。

2) sign convention  
   如果你把 rm_seg 全部乘以 -1 再 decode，看 BER 是否從 0.5 掉下來（快速試驗）。  
   你目前已用 UE dump 的值（-12..12），這條通常不是主因，但仍值得做 1 次實驗排除。

3) segment ordering / concat ordering  
   你目前 `cat seg00 seg01` 是合理的（OAI r_offset 也是 seg0 然後 seg1），但仍可用 UE `c[r]` dump 一次確認順序。

---

## 9. 本聊天室產出的關鍵指令清單（整理）

### 9.1 快速找出某個 symbol/區塊
```bash
grep -nE "est_packed|est_bits|llr_out" ~/openairinterface5g/openair1/PHY/CODING/TESTBENCH/ldpctest_spx.c
nl -ba ~/openairinterface5g/openair1/PHY/CODING/TESTBENCH/ldpctest_spx.c | sed -n '560,610p'
```

### 9.2 檢查 raw dump 是否為全 0
```bash
python3 - <<'PY'
import numpy as np
x = np.fromfile("d_unmatched_int16.bin", dtype=np.int16)
print("len", x.size, "min/max", int(x.min()), int(x.max()))
nz = int((x!=0).sum())
print("nonzero", nz, "ratio", nz/x.size)
print("head64", x[:64].tolist())
PY
```

### 9.3 concat seg00 + seg01
```bash
cat seg00.bin seg01.bin > d_unmatched_int16.bin
```

### 9.4 gdb 抓 segfault
```bash
gdb -q -ex "set pagination off" \
    -ex "run" \
    -ex "bt" \
    -ex "info registers" \
    -ex "quit" \
    --args ./ldpctest_spx d_unmatched_int16.bin ldpc_cfg.txt decoded_bits_direct.bin
```

### 9.5 BER 檢查
```bash
python3 - <<'PY'
import numpy as np
A=None
with open("ldpc_cfg.txt") as f:
    for line in f:
        p=line.split()
        if len(p)==2 and p[0]=="A":
            A=int(p[1]); break
tx = np.unpackbits(np.fromfile("txbits.bin",np.uint8), bitorder="big")[:A].astype(np.uint8)
dec = np.fromfile("decoded_bits_direct.bin",np.uint8)[:A].astype(np.uint8)
err = int((tx!=dec).sum())
print("A",A,"errors",err,"BER",err/A)
PY
```

---

## 10. 下一個聊天室的「一句話現況」

我們已經把 UE d_unmatched（rate-unmatch 後，LDPC core input）拉出來，外部 ldpctest_spx 也能穩定 decode，不再 segfault；但用 BITINT8 output mode 自己抽 bits 來重組 TB，與 gNB txbits 比對仍 BER≈0.5。  
下一步要 dump UE 端真正的 decoded bits（harq_process->c[r] 或 b[DLSCH_id]），確認 ground truth，然後用它來校正 wrapper 的 output mode / bit 抽取方式。
